/*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE */
const {
  entries: ht,
  setPrototypeOf: it,
  isFrozen: Bt,
  getPrototypeOf: Yt,
  getOwnPropertyDescriptor: qt
} = Object;
let {
  freeze: R,
  seal: I,
  create: Tt
} = Object, {
  apply: Ce,
  construct: ve
} = typeof Reflect < "u" && Reflect;
R || (R = function(n) {
  return n;
});
I || (I = function(n) {
  return n;
});
Ce || (Ce = function(n, t, o) {
  return n.apply(t, o);
});
ve || (ve = function(n, t) {
  return new n(...t);
});
const ce = O(Array.prototype.forEach), $t = O(Array.prototype.lastIndexOf), lt = O(Array.prototype.pop), V = O(Array.prototype.push), Xt = O(Array.prototype.splice), fe = O(String.prototype.toLowerCase), Ie = O(String.prototype.toString), at = O(String.prototype.match), K = O(String.prototype.replace), jt = O(String.prototype.indexOf), Vt = O(String.prototype.trim), D = O(Object.prototype.hasOwnProperty), N = O(RegExp.prototype.test), Z = Kt(TypeError);
function O(i) {
  return function(n) {
    n instanceof RegExp && (n.lastIndex = 0);
    for (var t = arguments.length, o = new Array(t > 1 ? t - 1 : 0), l = 1; l < t; l++)
      o[l - 1] = arguments[l];
    return Ce(i, n, o);
  };
}
function Kt(i) {
  return function() {
    for (var n = arguments.length, t = new Array(n), o = 0; o < n; o++)
      t[o] = arguments[o];
    return ve(i, t);
  };
}
function c(i, n) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fe;
  it && it(i, null);
  let o = n.length;
  for (; o--; ) {
    let l = n[o];
    if (typeof l == "string") {
      const u = t(l);
      u !== l && (Bt(n) || (n[o] = u), l = u);
    }
    i[l] = !0;
  }
  return i;
}
function Zt(i) {
  for (let n = 0; n < i.length; n++)
    D(i, n) || (i[n] = null);
  return i;
}
function P(i) {
  const n = Tt(null);
  for (const [t, o] of ht(i))
    D(i, t) && (Array.isArray(o) ? n[t] = Zt(o) : o && typeof o == "object" && o.constructor === Object ? n[t] = P(o) : n[t] = o);
  return n;
}
function Q(i, n) {
  for (; i !== null; ) {
    const o = qt(i, n);
    if (o) {
      if (o.get)
        return O(o.get);
      if (typeof o.value == "function")
        return O(o.value);
    }
    i = Yt(i);
  }
  function t() {
    return null;
  }
  return t;
}
const st = R(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), De = R(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), be = R(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Qt = R(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Me = R(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Jt = R(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ct = R(["#text"]), ut = R(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), we = R(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), ft = R(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), ue = R(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), en = I(/\{\{[\w\W]*|[\w\W]*\}\}/gm), tn = I(/<%[\w\W]*|[\w\W]*%>/gm), nn = I(/\$\{[\w\W]*/gm), rn = I(/^data-[\-\w.\u00B7-\uFFFF]+$/), on = I(/^aria-[\-\w]+$/), Et = I(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), ln = I(/^(?:\w+script|data):/i), an = I(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), gt = I(/^html$/i), sn = I(/^[a-z][.\w]*(-[.\w]+)+$/i);
var mt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: on,
  ATTR_WHITESPACE: an,
  CUSTOM_ELEMENT: sn,
  DATA_ATTR: rn,
  DOCTYPE_NAME: gt,
  ERB_EXPR: tn,
  IS_ALLOWED_URI: Et,
  IS_SCRIPT_OR_DATA: ln,
  MUSTACHE_EXPR: en,
  TMPLIT_EXPR: nn
});
const J = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, cn = function() {
  return typeof window > "u" ? null : window;
}, un = function(n, t) {
  if (typeof n != "object" || typeof n.createPolicy != "function")
    return null;
  let o = null;
  const l = "data-tt-policy-suffix";
  t && t.hasAttribute(l) && (o = t.getAttribute(l));
  const u = "dompurify" + (o ? "#" + o : "");
  try {
    return n.createPolicy(u, {
      createHTML(f) {
        return f;
      },
      createScriptURL(f) {
        return f;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + u + " could not be created."), null;
  }
}, pt = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function At() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : cn();
  const n = (s) => At(s);
  if (n.version = "3.2.5", n.removed = [], !i || !i.document || i.document.nodeType !== J.document || !i.Element)
    return n.isSupported = !1, n;
  let {
    document: t
  } = i;
  const o = t, l = o.currentScript, {
    DocumentFragment: u,
    HTMLTemplateElement: f,
    Node: m,
    Element: v,
    NodeFilter: W,
    NamedNodeMap: _t = i.NamedNodeMap || i.MozNamedAttrMap,
    HTMLFormElement: St,
    DOMParser: yt,
    trustedTypes: ee
  } = i, B = v.prototype, Nt = Q(B, "cloneNode"), Rt = Q(B, "remove"), Ot = Q(B, "nextSibling"), Lt = Q(B, "childNodes"), te = Q(B, "parentNode");
  if (typeof f == "function") {
    const s = t.createElement("template");
    s.content && s.content.ownerDocument && (t = s.content.ownerDocument);
  }
  let _, Y = "";
  const {
    implementation: me,
    createNodeIterator: It,
    createDocumentFragment: Dt,
    getElementsByTagName: bt
  } = t, {
    importNode: Mt
  } = o;
  let S = pt();
  n.isSupported = typeof ht == "function" && typeof te == "function" && me && me.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: pe,
    ERB_EXPR: de,
    TMPLIT_EXPR: he,
    DATA_ATTR: wt,
    ARIA_ATTR: Ct,
    IS_SCRIPT_OR_DATA: vt,
    ATTR_WHITESPACE: xe,
    CUSTOM_ELEMENT: xt
  } = mt;
  let {
    IS_ALLOWED_URI: Pe
  } = mt, h = null;
  const ke = c({}, [...st, ...De, ...be, ...Me, ...ct]);
  let E = null;
  const Ue = c({}, [...ut, ...we, ...ft, ...ue]);
  let d = Object.seal(Tt(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), q = null, Te = null, Fe = !0, Ee = !0, He = !1, ze = !0, k = !1, ge = !0, x = !1, Ae = !1, _e = !1, U = !1, ne = !1, re = !1, Ge = !0, We = !1;
  const Pt = "user-content-";
  let Se = !0, $ = !1, F = {}, H = null;
  const Be = c({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Ye = null;
  const qe = c({}, ["audio", "video", "img", "source", "image", "track"]);
  let ye = null;
  const $e = c({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), oe = "http://www.w3.org/1998/Math/MathML", ie = "http://www.w3.org/2000/svg", w = "http://www.w3.org/1999/xhtml";
  let z = w, Ne = !1, Re = null;
  const kt = c({}, [oe, ie, w], Ie);
  let le = c({}, ["mi", "mo", "mn", "ms", "mtext"]), ae = c({}, ["annotation-xml"]);
  const Ut = c({}, ["title", "style", "font", "a", "script"]);
  let X = null;
  const Ft = ["application/xhtml+xml", "text/html"], Ht = "text/html";
  let T = null, G = null;
  const zt = t.createElement("form"), Xe = function(e) {
    return e instanceof RegExp || e instanceof Function;
  }, Oe = function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(G && G === e)) {
      if ((!e || typeof e != "object") && (e = {}), e = P(e), X = // eslint-disable-next-line unicorn/prefer-includes
      Ft.indexOf(e.PARSER_MEDIA_TYPE) === -1 ? Ht : e.PARSER_MEDIA_TYPE, T = X === "application/xhtml+xml" ? Ie : fe, h = D(e, "ALLOWED_TAGS") ? c({}, e.ALLOWED_TAGS, T) : ke, E = D(e, "ALLOWED_ATTR") ? c({}, e.ALLOWED_ATTR, T) : Ue, Re = D(e, "ALLOWED_NAMESPACES") ? c({}, e.ALLOWED_NAMESPACES, Ie) : kt, ye = D(e, "ADD_URI_SAFE_ATTR") ? c(P($e), e.ADD_URI_SAFE_ATTR, T) : $e, Ye = D(e, "ADD_DATA_URI_TAGS") ? c(P(qe), e.ADD_DATA_URI_TAGS, T) : qe, H = D(e, "FORBID_CONTENTS") ? c({}, e.FORBID_CONTENTS, T) : Be, q = D(e, "FORBID_TAGS") ? c({}, e.FORBID_TAGS, T) : {}, Te = D(e, "FORBID_ATTR") ? c({}, e.FORBID_ATTR, T) : {}, F = D(e, "USE_PROFILES") ? e.USE_PROFILES : !1, Fe = e.ALLOW_ARIA_ATTR !== !1, Ee = e.ALLOW_DATA_ATTR !== !1, He = e.ALLOW_UNKNOWN_PROTOCOLS || !1, ze = e.ALLOW_SELF_CLOSE_IN_ATTR !== !1, k = e.SAFE_FOR_TEMPLATES || !1, ge = e.SAFE_FOR_XML !== !1, x = e.WHOLE_DOCUMENT || !1, U = e.RETURN_DOM || !1, ne = e.RETURN_DOM_FRAGMENT || !1, re = e.RETURN_TRUSTED_TYPE || !1, _e = e.FORCE_BODY || !1, Ge = e.SANITIZE_DOM !== !1, We = e.SANITIZE_NAMED_PROPS || !1, Se = e.KEEP_CONTENT !== !1, $ = e.IN_PLACE || !1, Pe = e.ALLOWED_URI_REGEXP || Et, z = e.NAMESPACE || w, le = e.MATHML_TEXT_INTEGRATION_POINTS || le, ae = e.HTML_INTEGRATION_POINTS || ae, d = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && Xe(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (d.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && Xe(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (d.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (d.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), k && (Ee = !1), ne && (U = !0), F && (h = c({}, ct), E = [], F.html === !0 && (c(h, st), c(E, ut)), F.svg === !0 && (c(h, De), c(E, we), c(E, ue)), F.svgFilters === !0 && (c(h, be), c(E, we), c(E, ue)), F.mathMl === !0 && (c(h, Me), c(E, ft), c(E, ue))), e.ADD_TAGS && (h === ke && (h = P(h)), c(h, e.ADD_TAGS, T)), e.ADD_ATTR && (E === Ue && (E = P(E)), c(E, e.ADD_ATTR, T)), e.ADD_URI_SAFE_ATTR && c(ye, e.ADD_URI_SAFE_ATTR, T), e.FORBID_CONTENTS && (H === Be && (H = P(H)), c(H, e.FORBID_CONTENTS, T)), Se && (h["#text"] = !0), x && c(h, ["html", "head", "body"]), h.table && (c(h, ["tbody"]), delete q.tbody), e.TRUSTED_TYPES_POLICY) {
        if (typeof e.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Z('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof e.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Z('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        _ = e.TRUSTED_TYPES_POLICY, Y = _.createHTML("");
      } else
        _ === void 0 && (_ = un(ee, l)), _ !== null && typeof Y == "string" && (Y = _.createHTML(""));
      R && R(e), G = e;
    }
  }, je = c({}, [...De, ...be, ...Qt]), Ve = c({}, [...Me, ...Jt]), Gt = function(e) {
    let r = te(e);
    (!r || !r.tagName) && (r = {
      namespaceURI: z,
      tagName: "template"
    });
    const a = fe(e.tagName), p = fe(r.tagName);
    return Re[e.namespaceURI] ? e.namespaceURI === ie ? r.namespaceURI === w ? a === "svg" : r.namespaceURI === oe ? a === "svg" && (p === "annotation-xml" || le[p]) : !!je[a] : e.namespaceURI === oe ? r.namespaceURI === w ? a === "math" : r.namespaceURI === ie ? a === "math" && ae[p] : !!Ve[a] : e.namespaceURI === w ? r.namespaceURI === ie && !ae[p] || r.namespaceURI === oe && !le[p] ? !1 : !Ve[a] && (Ut[a] || !je[a]) : !!(X === "application/xhtml+xml" && Re[e.namespaceURI]) : !1;
  }, b = function(e) {
    V(n.removed, {
      element: e
    });
    try {
      te(e).removeChild(e);
    } catch {
      Rt(e);
    }
  }, se = function(e, r) {
    try {
      V(n.removed, {
        attribute: r.getAttributeNode(e),
        from: r
      });
    } catch {
      V(n.removed, {
        attribute: null,
        from: r
      });
    }
    if (r.removeAttribute(e), e === "is")
      if (U || ne)
        try {
          b(r);
        } catch {
        }
      else
        try {
          r.setAttribute(e, "");
        } catch {
        }
  }, Ke = function(e) {
    let r = null, a = null;
    if (_e)
      e = "<remove></remove>" + e;
    else {
      const g = at(e, /^[\r\n\t ]+/);
      a = g && g[0];
    }
    X === "application/xhtml+xml" && z === w && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
    const p = _ ? _.createHTML(e) : e;
    if (z === w)
      try {
        r = new yt().parseFromString(p, X);
      } catch {
      }
    if (!r || !r.documentElement) {
      r = me.createDocument(z, "template", null);
      try {
        r.documentElement.innerHTML = Ne ? Y : p;
      } catch {
      }
    }
    const A = r.body || r.documentElement;
    return e && a && A.insertBefore(t.createTextNode(a), A.childNodes[0] || null), z === w ? bt.call(r, x ? "html" : "body")[0] : x ? r.documentElement : A;
  }, Ze = function(e) {
    return It.call(
      e.ownerDocument || e,
      e,
      // eslint-disable-next-line no-bitwise
      W.SHOW_ELEMENT | W.SHOW_COMMENT | W.SHOW_TEXT | W.SHOW_PROCESSING_INSTRUCTION | W.SHOW_CDATA_SECTION,
      null
    );
  }, Le = function(e) {
    return e instanceof St && (typeof e.nodeName != "string" || typeof e.textContent != "string" || typeof e.removeChild != "function" || !(e.attributes instanceof _t) || typeof e.removeAttribute != "function" || typeof e.setAttribute != "function" || typeof e.namespaceURI != "string" || typeof e.insertBefore != "function" || typeof e.hasChildNodes != "function");
  }, Qe = function(e) {
    return typeof m == "function" && e instanceof m;
  };
  function C(s, e, r) {
    ce(s, (a) => {
      a.call(n, e, r, G);
    });
  }
  const Je = function(e) {
    let r = null;
    if (C(S.beforeSanitizeElements, e, null), Le(e))
      return b(e), !0;
    const a = T(e.nodeName);
    if (C(S.uponSanitizeElement, e, {
      tagName: a,
      allowedTags: h
    }), e.hasChildNodes() && !Qe(e.firstElementChild) && N(/<[/\w!]/g, e.innerHTML) && N(/<[/\w!]/g, e.textContent) || e.nodeType === J.progressingInstruction || ge && e.nodeType === J.comment && N(/<[/\w]/g, e.data))
      return b(e), !0;
    if (!h[a] || q[a]) {
      if (!q[a] && tt(a) && (d.tagNameCheck instanceof RegExp && N(d.tagNameCheck, a) || d.tagNameCheck instanceof Function && d.tagNameCheck(a)))
        return !1;
      if (Se && !H[a]) {
        const p = te(e) || e.parentNode, A = Lt(e) || e.childNodes;
        if (A && p) {
          const g = A.length;
          for (let L = g - 1; L >= 0; --L) {
            const M = Nt(A[L], !0);
            M.__removalCount = (e.__removalCount || 0) + 1, p.insertBefore(M, Ot(e));
          }
        }
      }
      return b(e), !0;
    }
    return e instanceof v && !Gt(e) || (a === "noscript" || a === "noembed" || a === "noframes") && N(/<\/no(script|embed|frames)/i, e.innerHTML) ? (b(e), !0) : (k && e.nodeType === J.text && (r = e.textContent, ce([pe, de, he], (p) => {
      r = K(r, p, " ");
    }), e.textContent !== r && (V(n.removed, {
      element: e.cloneNode()
    }), e.textContent = r)), C(S.afterSanitizeElements, e, null), !1);
  }, et = function(e, r, a) {
    if (Ge && (r === "id" || r === "name") && (a in t || a in zt))
      return !1;
    if (!(Ee && !Te[r] && N(wt, r))) {
      if (!(Fe && N(Ct, r))) {
        if (!E[r] || Te[r]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(tt(e) && (d.tagNameCheck instanceof RegExp && N(d.tagNameCheck, e) || d.tagNameCheck instanceof Function && d.tagNameCheck(e)) && (d.attributeNameCheck instanceof RegExp && N(d.attributeNameCheck, r) || d.attributeNameCheck instanceof Function && d.attributeNameCheck(r)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            r === "is" && d.allowCustomizedBuiltInElements && (d.tagNameCheck instanceof RegExp && N(d.tagNameCheck, a) || d.tagNameCheck instanceof Function && d.tagNameCheck(a)))
          ) return !1;
        } else if (!ye[r]) {
          if (!N(Pe, K(a, xe, ""))) {
            if (!((r === "src" || r === "xlink:href" || r === "href") && e !== "script" && jt(a, "data:") === 0 && Ye[e])) {
              if (!(He && !N(vt, K(a, xe, "")))) {
                if (a)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, tt = function(e) {
    return e !== "annotation-xml" && at(e, xt);
  }, nt = function(e) {
    C(S.beforeSanitizeAttributes, e, null);
    const {
      attributes: r
    } = e;
    if (!r || Le(e))
      return;
    const a = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: E,
      forceKeepAttr: void 0
    };
    let p = r.length;
    for (; p--; ) {
      const A = r[p], {
        name: g,
        namespaceURI: L,
        value: M
      } = A, j = T(g);
      let y = g === "value" ? M : Vt(M);
      if (a.attrName = j, a.attrValue = y, a.keepAttr = !0, a.forceKeepAttr = void 0, C(S.uponSanitizeAttribute, e, a), y = a.attrValue, We && (j === "id" || j === "name") && (se(g, e), y = Pt + y), ge && N(/((--!?|])>)|<\/(style|title)/i, y)) {
        se(g, e);
        continue;
      }
      if (a.forceKeepAttr || (se(g, e), !a.keepAttr))
        continue;
      if (!ze && N(/\/>/i, y)) {
        se(g, e);
        continue;
      }
      k && ce([pe, de, he], (ot) => {
        y = K(y, ot, " ");
      });
      const rt = T(e.nodeName);
      if (et(rt, j, y)) {
        if (_ && typeof ee == "object" && typeof ee.getAttributeType == "function" && !L)
          switch (ee.getAttributeType(rt, j)) {
            case "TrustedHTML": {
              y = _.createHTML(y);
              break;
            }
            case "TrustedScriptURL": {
              y = _.createScriptURL(y);
              break;
            }
          }
        try {
          L ? e.setAttributeNS(L, g, y) : e.setAttribute(g, y), Le(e) ? b(e) : lt(n.removed);
        } catch {
        }
      }
    }
    C(S.afterSanitizeAttributes, e, null);
  }, Wt = function s(e) {
    let r = null;
    const a = Ze(e);
    for (C(S.beforeSanitizeShadowDOM, e, null); r = a.nextNode(); )
      C(S.uponSanitizeShadowNode, r, null), Je(r), nt(r), r.content instanceof u && s(r.content);
    C(S.afterSanitizeShadowDOM, e, null);
  };
  return n.sanitize = function(s) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = null, a = null, p = null, A = null;
    if (Ne = !s, Ne && (s = "<!-->"), typeof s != "string" && !Qe(s))
      if (typeof s.toString == "function") {
        if (s = s.toString(), typeof s != "string")
          throw Z("dirty is not a string, aborting");
      } else
        throw Z("toString is not a function");
    if (!n.isSupported)
      return s;
    if (Ae || Oe(e), n.removed = [], typeof s == "string" && ($ = !1), $) {
      if (s.nodeName) {
        const M = T(s.nodeName);
        if (!h[M] || q[M])
          throw Z("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (s instanceof m)
      r = Ke("<!---->"), a = r.ownerDocument.importNode(s, !0), a.nodeType === J.element && a.nodeName === "BODY" || a.nodeName === "HTML" ? r = a : r.appendChild(a);
    else {
      if (!U && !k && !x && // eslint-disable-next-line unicorn/prefer-includes
      s.indexOf("<") === -1)
        return _ && re ? _.createHTML(s) : s;
      if (r = Ke(s), !r)
        return U ? null : re ? Y : "";
    }
    r && _e && b(r.firstChild);
    const g = Ze($ ? s : r);
    for (; p = g.nextNode(); )
      Je(p), nt(p), p.content instanceof u && Wt(p.content);
    if ($)
      return s;
    if (U) {
      if (ne)
        for (A = Dt.call(r.ownerDocument); r.firstChild; )
          A.appendChild(r.firstChild);
      else
        A = r;
      return (E.shadowroot || E.shadowrootmode) && (A = Mt.call(o, A, !0)), A;
    }
    let L = x ? r.outerHTML : r.innerHTML;
    return x && h["!doctype"] && r.ownerDocument && r.ownerDocument.doctype && r.ownerDocument.doctype.name && N(gt, r.ownerDocument.doctype.name) && (L = "<!DOCTYPE " + r.ownerDocument.doctype.name + `>
` + L), k && ce([pe, de, he], (M) => {
      L = K(L, M, " ");
    }), _ && re ? _.createHTML(L) : L;
  }, n.setConfig = function() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Oe(s), Ae = !0;
  }, n.clearConfig = function() {
    G = null, Ae = !1;
  }, n.isValidAttribute = function(s, e, r) {
    G || Oe({});
    const a = T(s), p = T(e);
    return et(a, p, r);
  }, n.addHook = function(s, e) {
    typeof e == "function" && V(S[s], e);
  }, n.removeHook = function(s, e) {
    if (e !== void 0) {
      const r = $t(S[s], e);
      return r === -1 ? void 0 : Xt(S[s], r, 1)[0];
    }
    return lt(S[s]);
  }, n.removeHooks = function(s) {
    S[s] = [];
  }, n.removeAllHooks = function() {
    S = pt();
  }, n;
}
var dt = At();
const fn = {
  select(i) {
    return {
      count(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        if (n) {
          let o = 0;
          return n === "*" ? o = t.reduce((l, u) => l + u.children.length, 0) : t.forEach((l) => {
            o += l.querySelectorAll(n).length;
          }), t = null, o;
        } else {
          console.error("No target provided to count!");
          return;
        }
      },
      sum(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        if (n) {
          let o = 0, l;
          return n === "*" ? t.forEach((u) => {
            l = Array.from(u.children), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o += isNaN(m) ? 0 : m;
            });
          }) : t.forEach((u) => {
            l = u.querySelectorAll(n), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o += isNaN(m) ? 0 : m;
            });
          }), l = null, t = null, o;
        } else {
          console.error("No target provided to sum!");
          return;
        }
      },
      avg(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        if (n) {
          let o = 0, l = 0, u;
          return n === "*" ? t.forEach((f) => {
            u = Array.from(f.children), u.forEach((m) => {
              const v = parseFloat(m.innerText);
              o += isNaN(v) ? 0 : v, l++;
            });
          }) : t.forEach((f) => {
            u = f.querySelectorAll(n), u.forEach((m) => {
              const v = parseFloat(m.innerText);
              o += isNaN(v) ? 0 : v, l++;
            });
          }), u = null, t = null, l > 0 ? o / l : 0;
        } else {
          console.error("No target provided to average!");
          return;
        }
      },
      min(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        if (n) {
          let o = 1 / 0, l;
          return n === "*" ? t.forEach((u) => {
            l = Array.from(u.children), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o = Math.min(o, isNaN(m) ? 1 / 0 : m);
            });
          }) : t.forEach((u) => {
            l = u.querySelectorAll(n), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o = Math.min(o, isNaN(m) ? 1 / 0 : m);
            });
          }), l = null, t = null, o === 1 / 0 ? null : o;
        } else {
          console.error("No target provided to minimum!");
          return;
        }
      },
      max(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        if (n) {
          let o = -1 / 0, l;
          return n === "*" ? t.forEach((u) => {
            l = Array.from(u.children), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o = Math.max(o, isNaN(m) ? -1 / 0 : m);
            });
          }) : t.forEach((u) => {
            l = u.querySelectorAll(n), l.forEach((f) => {
              const m = parseFloat(f.innerText);
              o = Math.max(o, isNaN(m) ? -1 / 0 : m);
            });
          }), l = null, t = null, o === -1 / 0 ? null : o;
        } else {
          console.error("No target provided to maximum!");
          return;
        }
      }
    };
  },
  insert(i) {
    return {
      into(n) {
        let t;
        if (n) {
          if (t = document.querySelectorAll(n), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${n} selector!`);
            return;
          }
          t.forEach((o) => {
            o.innerHTML += dt.sanitize(i);
          });
        } else {
          console.error("No selector provided!");
          return;
        }
        t = null;
      }
    };
  },
  update(i) {
    return {
      set(n) {
        let t;
        if (i) {
          if (t = document.querySelectorAll(i), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${i} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        typeof n == "object" ? Object.entries(n).forEach((o) => {
          const [l, u] = o;
          if (l === "text") {
            t.forEach((f) => {
              f.innerText = u;
            });
            return;
          }
          if (l === "html") {
            t.forEach((f) => {
              f.innerHTML = dt.sanitize(u);
            });
            return;
          }
          t.forEach((f) => {
            f.style[l] = u;
          });
        }) : console.error(n !== void 0 ? "Invalid content type! Expected object!" : "No content provided to update!"), t = null;
      }
    };
  },
  delete(i) {
    return {
      from(n) {
        let t;
        if (n) {
          if (t = document.querySelectorAll(n), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${n} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        !i || i === "*" ? t.forEach((o) => {
          o.innerHTML = "";
        }) : t.forEach((o) => {
          let l = o.querySelectorAll(i);
          if (l = l.length === 0 ? l : Array.from(l), !l.length) {
            console.error(`No child element with ${i} selector!`);
            return;
          }
          l.forEach((u) => {
            u.innerHTML = "";
          }), l = null;
        }), t = null;
      }
    };
  },
  drop(i) {
    let n;
    if (i) {
      if (n = document.querySelectorAll(i), n = n.length === 0 ? n : Array.from(n), !n.length) {
        console.error(`No element with ${i} selector!`);
        return;
      }
      n.forEach((t) => {
        t.remove();
      });
    } else {
      console.error("No selector provided!");
      return;
    }
    n = null;
  },
  createTrigger(i) {
    return {
      on(n) {
        let t;
        if (n) {
          if (t = document.querySelectorAll(n), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${n} selector!`);
            return;
          }
        } else {
          console.error("No selector provided!");
          return;
        }
        return {
          execute(o) {
            t.forEach((l) => {
              l.addEventListener(i, o);
            }), t = null;
          }
        };
      }
    };
  },
  executeTrigger(i) {
    return {
      on(n) {
        let t;
        if (n) {
          if (t = document.querySelectorAll(n), t = t.length === 0 ? t : Array.from(t), !t.length) {
            console.error(`No element with ${n} selector!`);
            return;
          }
          t.forEach((o) => {
            let l = new Event(i);
            o.dispatchEvent(l), l = null;
          });
        } else {
          console.error("No selector provided!");
          return;
        }
        t = null;
      }
    };
  }
};
window.QDOM = fn;
